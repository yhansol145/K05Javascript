<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>J08Function03.html</title>
    <script>

        /*
        Call by value : 값에 의한 호출. 값을 매개변수로 전달하면
            메모리상에서 복사가 일어나서 전달되는 형식.
            함수내에서는 지역변수가 되므로 함수가 종료되면 자동으로 소멸된다.
        */
        var param = 100, args = 1;

        document.write("<h2>Call by value</h2>");
        document.write("초기값 param=" + param + ", args=" + args + "<br/>");

        function callByValue(param, args) {

            /*
            매개변수로 전달된 값은 메모리상에서 복사되어 해당 지역의
            지역변수가 된다. 해당 변수는 전역변수와 충돌되지만 지역변수가
            우선순위가 높으므로 함수내에서만 사용되는 지역변수가 된다.
            */
            var temp = param;
            param = args;
            args = temp;
            // 함수안에서는 값이 바뀜
            document.write("함수안의 param=" + param + ", args=" + args + "<br/>");
        }
        callByValue(param, args);
        // 기존의 값을 그대로 유지함
        document.write("함수밖의 param=" + param + ", args=" + args + "<br/>");


        /*
        Call by Reference : 참조에 의한 호출. 값이 아닌 객체의 참조값(주소값)을
            전달하여, 지역에 상관없이 동일한 객체의 참조가 가능함
        */
        document.write("<h2>Call by Reference</h2>");
        var array = [100, 1];
        document.write("초기값 array[0]=" + array[0] + ", array[1]=" + array[1] + "<br/>");

        function callByReference(arr) {

            /*
            배열의 참조값을 통해 값이 교환되므로, 실제 배열에 값이 적용된다.
            */
            var temp = arr[0];
            arr[0] = arr[1];
            arr[1] = temp;

            document.write("함수안 arr[0]=" + arr[0] + ", arr[1]=" + arr[1] + "<br/>");
        }

        callByReference(array);
        document.write("함수밖 array[0]=" + array[0] + ", array[1]=" + array[1] + "<br/>")




        document.write("<h2>배열을 크기순으로 정렬하기</h2>");
        /*
        연습문제] 다음 배열을 오름차순으로 정렬하는 함수를 정의하시오. 단, 
        정렬전과 정렬후의 결과를 모두 출력해야 한다. 
        */
        var arr = [10, 45, 99, 1, 34, 78, 100, 22, 2, 55];
        function setOrdering(arrParam) {

            for (var i = 0; i < arrParam.length - 1; i++) {
                /*
                1회전을 하면 가장 큰수가 뒤로 이동하기 때문에
                두번째 회전에서는 배열크기 -1만큼만 비교하면 된다.
                따라서 i가 증가하면 j는 줄어든다.
                */
                for (var j = 0; j < (arrParam.length - 1) - i; j++) {

                    if (arrParam[j] > arrParam[j + 1]) {
                        /*
                        j번째 요소와 j+1번째 요소를 비교한 후 j번째가 크다면 교환한다.
                        */
                        temp = arrParam[j];
                        arrParam[j] = arrParam[j + 1]
                        arrParam[j + 1] = temp;
                        showArray(arrParam);
                    }
                }
            }

            // arr.sort(function (a, b) {
            //     return a - b;
            // });
        }
        function showArray(arrParam) {
            //배열의 크기만큼 반복하면서 요소 출력
            for (var i = 0; i < arrParam.length; i++) {
                document.write(arrParam[i] + "&nbsp;");
            }
            document.write("<br/>");
        }
        //정렬전 배열 출력
        showArray(arr);
        //정렬 실행(오름차순)
        setOrdering(arr);
        //정렬후 배열 출력
        showArray(arr);
    </script>
</head>

<body>

</body>

</html>